<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="answer">
  <meta name="keywords"  content="">
  <!-- <link rel="shortcut icon" href="/img/favicon.ico"> -->

  <title>合并排序 - matrix answer</title>

  <link rel="canonical" href="https://matrixans.github.io/2016/02/20/merge-sort.html">
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/mensu-blog.css">
  <link rel="stylesheet" href="/css/monokai_sublime.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">

  <!-- Hux Delete, sad but pending in China
  <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
  css'>
  -->


  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about.html">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags.html">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<div id="backtotop">
  <div class="backtotop-btn">
    <div class="arrow-upward"></div>
    <div class="vertical-stick"></div>
  </div>
</div>

<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/" width="0" height="0"> -->

<!-- header -->
<header class="intro-header" >
  <div class="container">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <div class="post-heading">
        <div class="tags">
          
          <a class="tag" href="/tags.html#排序" title="排序">排序</a>
          
        </div>
        <h1>合并排序</h1>
        
        
        <h2 class="subheading">merge sort</h2>
        
        <span class="meta">last edited by Mensu on 2016-03-17</span>
      </div>
    </div>
  </div>
</header>

<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2
                      col-md-10 col-md-offset-1
                      post-container">
          <ul class="pager pager-top">
            
            
            <li class="next">
                <a href="/2016/03/13/output-format-comparison-between-printf-and-stream.html" data-toggle="tooltip" data-placement="top" title="常用输出格式归纳：printf 和 stream">Next Post &rarr;</a>
            </li>
            
        </ul>

          <blockquote>
  <p>The article was initially posted on <strong>2016-02-20</strong>.</p>
</blockquote>

<h1 id="section">合并排序的核心部分</h1>

<h2 id="section-1">打个比方</h2>
<p>合并排序的核心，是将两个<strong>内部有序</strong>的数组，合并为一个有序的数组</p>

<p>具体的想法很好理解，有点类似于两个队伍打比赛</p>

<p>队伍都按照<strong>由弱到强</strong>的顺序派出队员，每次都是1v1的个人赛，赢的人留在台上做擂主，输的人排入休息队伍【别问为啥 |･ω･｀)<br />
然后，输者的队伍继续派出队员，直到有一个队伍的人都派完了，才把另一个队伍的人按顺序接到输者休息队伍的后面</p>

<p>这样以后，休息队伍就是按由弱到强的顺序排的啦</p>

<h2 id="section-2">举个栗子</h2>
<p>下面的 beforemerger 数组里存有两个待合并的数组，分别是 1、2、4、5 和 3、5、6、7。aftermerger 储存排序后的数组。用 p1、p2、p 三个“指针”表示三个会移动的下标</p>

<p>“指针”的说法只是为了形象地表示箭头，和C语言储存地址的指针无关</p>

<p><a class="view-again" href="javascript:;">从头看起 <i class="fa fa-refresh"></i></a></p>

<p><img src="http://7xrahq.com1.z0.glb.clouddn.com/merge-sort-merge-sort.gif" alt="an example for merge sort" /></p>

<p>从上面的例子，可以看出核心部分分为两个阶段：两个组的<strong>交叉</strong>填入阶段、剩下一个组剩余内容的<strong>移入</strong>阶段</p>

<h2 id="section-3">交叉</h2>
<p>这个阶段就是循环 &lt; 比较大小、移动指针 &gt;，直到指针出界。根据上面的栗子，具体过程可以抽象为下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// invalid code
</span><span class="n">loop</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="p">{</span>   <span class="c1">// p1的数小
</span>        <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">];</span>        <span class="c1">// 就将p1的数填入
</span>        <span class="n">p1</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>                                <span class="c1">// 移动指针
</span>    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>                                   <span class="c1">// p2的数小
</span>        <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">];</span>   <span class="c1">// 就将p2的数填入
</span>        <span class="n">p2</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>                           <span class="c1">// 移动指针
</span>    <span class="p">}</span>
     <span class="c1">// 用end1表示第一组最后一个数的下标（末下标），end2表示第二组的末下标
</span><span class="p">}</span> <span class="n">until</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">end1</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&gt;</span> <span class="n">end2</span><span class="p">);</span>            <span class="c1">// 有一组的指针出界，本阶段结束
</span></code></pre>
</div>

<p>仔细观察上面的代码，不难发现条件判断其实是把<strong>不同条件下的不同值</strong>赋给<strong>相同的变量 aftermerger[p]</strong>，以及不同的指针后移，于是可以考虑下面的形式：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">];</span>
<span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">p1</span><span class="o">++</span> <span class="o">:</span> <span class="n">p2</span><span class="o">++</span><span class="p">;</span>
<span class="n">p</span><span class="o">++</span><span class="p">;</span>
 
</code></pre>
</div>

<p>或者更为简洁的</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
 
</code></pre>
</div>

<p>当然，简洁的另一面，代码的可读性在一定程度上会有所下降</p>

<p>再对 loop…until 进行转换，就得到了</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
 
</code></pre>
</div>

<h2 id="section-4">移入</h2>
<p>移入阶段，如果是第一组有剩余，则循环 &lt; 将第一组 p1 以后的数分别存入aftermerger、移动指针 &gt;；如果第二组有剩余也类似</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// invalid code
</span><span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="p">{</span>                            <span class="c1">// p1所在组有剩余的情况
</span>    <span class="n">loop</span> <span class="p">{</span>
        <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">];</span>   <span class="c1">// 存入aftermerger
</span>        <span class="n">p1</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>                           <span class="c1">// 移动指针
</span>    <span class="p">}</span> <span class="n">until</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">end1</span><span class="p">);</span>                     <span class="c1">// p1指针也出界了，结束
</span><span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="p">{</span>                       <span class="c1">// p2所在组有剩余的情况，同理
</span>    <span class="n">loop</span> <span class="p">{</span>
        <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">];</span>  
        <span class="n">p2</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">until</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">end2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>交叉阶段的结束，意味着 <code class="highlighter-rouge">p1 &lt;= end1</code> 和 <code class="highlighter-rouge">p2 &lt;= end2</code> 中必有一种不成立，而且这两种情况是互斥的。因此可以大胆地去掉 else，而不用担心两个 if 内的语句都被执行
在此基础上合并 if … loop …until，可以得到更简洁的代码</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
</code></pre>
</div>

<p>下面的版本只有一行，但似乎增加了比较次数，可读性也比上面的差些，我是不太喜欢</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
 
</code></pre>
</div>

<h2 id="section-5">核心部分的代码</h2>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
 
</code></pre>
</div>

<p>可以看出，核心部分用到了5个关键的下标：</p>
<style type="text/css">
p.pre-wrap-center {
  text-align: center;
  white-space: pre-wrap;
}
</style>

<p class="pre-wrap-center">p = p1 = 第一组首下标
end1 = 第一组末下标
p2 = 第二组首下标
end2 = 第二组末下标</p>

<p>甚至可以认为，无论每组有多少个数，只要每组的首下标和末下标设置好，就可以进行合并排序的核心部分</p>

<h1 id="section-6">合并排序的迭代部分</h1>

<h2 id="section-7">迭代思路</h2>
<p>迭代的意思是把循环中这一轮的结果用于下一轮</p>

<p>根据合并排序的核心部分，可以这么想：用合并排序核心部分把<strong>两个内部有序的小组</strong>合并成<strong>一个内部有序大组</strong>（这一轮的结果），再拿这个大组和另外一个大组进行合并排序（用于下一轮），得到更大的组，再……</p>

<p>假如一开始就把一个无序的数组分成很多个小组，<strong>例如，每个数自成一组，</strong>按上面的想法合并这些内部有序的小组，再合并得到的内部有序的大组，这样下去，最终便可以把原数组变成内部有序的大组，即通过合并排序给整个数组排了序</p>

<p>要是我们把核心部分视为最小单位，那么迭代部分就是<strong>从左到右（内）</strong>和<strong>从上到下（外）</strong>的两层循环，举个栗子：</p>

<p><a class="view-again" href="javascript:;">从头看起 <i class="fa fa-refresh"></i></a></p>

<p><img src="http://7xrahq.com1.z0.glb.clouddn.com/merge-sort-merge-sort-iteration.gif" alt="an example for merge sort iteration" /></p>

<p>先<strong>从左到右循环核心部分</strong>：两个两个小组用核心部分排序</p>

<p>然后再<strong>从上到下循环</strong>前面的<strong>从左到右</strong>：发生迭代，把本轮从左到右循环的结果用于下一轮，每轮一个小组的大小是上一次两个小组大小之和，也就是上一次一个小组的两倍。这里暂时忽略了末尾的特殊情况</p>

<h2 id="section-8">从左到右</h2>

<p>先看从左到右的内循环，循环的内容是核心部分</p>

<h3 id="section-9">小组指针初始化</h3>

<p>在运用核心部分进行排序之前，要设置好每组的首尾指针，也就是说让 beforemerger 中两小组的首尾指针指向正确的位置</p>

<p>容易发现，进行核心部分之后，aftermerger 中的 p 指针总是能自动指向正确的位置——第一组的第一个元素——因此在从左到右的内循环中不需要刻意修改</p>

<p>这里我们使用 seg 表示每个标准小组的长度（元素数目），seg 的变化——每轮的长度是上一轮的两倍——将在外循环中修改</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
<span class="n">end1</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">end2</span> <span class="o">=</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
</code></pre>
</div>

<h4 id="section-10">两种特殊情况</h4>
<p>现在考虑末尾的特殊情况。因为标准小组的长度 seg 是 2 的 n 次方，而原数组的长度不一定恰好为 2 * seg 的倍数，也就是说最后可能剩下一些数，数量不足以凑成 2 个标准小组参与合并。不用害怕，我们要做的，还是<strong>让每组的首尾指针指向正确的位置</strong>。这样一来，如前面所说，就可以正确地进行核心部分。有如下两种特殊情况</p>

<p>一种是<strong>最后有两组</strong>能参与合并排序，但第二组里的数少于标准小组。这时只要<strong>把第二组的尾指针调整向</strong> rightmost——<strong>下标最大值</strong><br />
这种情况的本质是 正常情况下的 end2（= end1 + seg） 超过了 rightmost，此时要将 end2 调整为 rightmost<br />
我们力求修改后的代码也能用于前面的正常情况</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">if</span> <span class="p">(</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 第一种情况的本质：end1 + seg 超过了 rightmost
</span>	<span class="n">end2</span> <span class="o">=</span> <span class="n">rightmost</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                         <span class="c1">// 正常情况
</span>	<span class="n">end2</span> <span class="o">=</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>化简得</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
</code></pre>
</div>

<p>另一种则是<strong>最后只有一组</strong>能参与合并排序。我们可以认为，“第二组”的长度是0，于是，不用排了，这最后一组直接晋级下一轮外循环。这种情况的本质是 正常算得的 end1（= p2 - 1）等于或超过了 rightmost，此时需要修改 end1，使 end1 指向 rightmost</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>不难发现，条件里的等号去掉也不会对结果造成影响</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>然后，直接晋级，也就是说核心阶段里只想要执行这句话</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span> 
</code></pre>
</div>

<p>那么，破坏其他两句的条件 <code class="highlighter-rouge">p2 &lt;= end2</code> ，让 p2 &gt; end2 就行了。很幸运，如果沿用第一种特殊情况的</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
</code></pre>
</div>

<p>考虑到 end1 此时的位置 end1 = rightmost，代入上面的代码，结果必然是 end2 = rightmost。那么根据第二种特殊情况的本质—— p2 - 1 &gt;= rightmost ，立即推出</p>
<p class="pre-wrap-center">p2 &gt; p2 - 1 ≥ rightmost = end2</p>
<p>可见，沿用第一种特殊情况的代码还能顺便破坏 <code class="highlighter-rouge">p2 &lt;= end2</code> ，不用再写其他代码。但要注意 end1 那句要放在 end2 的前面</p>

<p>考虑上特殊情况，小组指针初始化的代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
<span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="for">for循环</h3>
<p>从左到右内循环的主体就这样搭建完成了：“小组指针初始化” + “核心部分“<br />
考虑内循环的开始——要为五指针声明，然后要把 aftermerger 中的 p 初始化为 0<br />
而内循环的终止条件，便是 p 指针遍历了所有的元素，溢出 aftermerger 数组的最右 rightmost 。反过来内循环还要继续的条件，是p指针尚未越过 rightmost。<br />
由此可以构造 for 循环：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;)</span> <span class="p">{</span>
    <span class="c1">// 小组指针初始化
</span>    <span class="c1">// 核心部分
</span><span class="p">}</span>
</code></pre>
</div>

<h3 id="section-11">从左到右循环的代码</h3>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;)</span> <span class="p">{</span>
    <span class="cm">/*----- 小组指针初始化 -----*/</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
    <span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
    
    <span class="cm">/*----- 核心部分 -----*/</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>
 
</code></pre>
</div>

<h2 id="section-12">从上到下</h2>

<h3 id="section-13">迭代思路</h3>

<p>从上到下循环的内容是上面从左到右的部分</p>

<p>每进行一次从左到右，就会两组两组合并，得到一些更大的组。不考虑特殊情况的话，每一轮，每组的长度 seg 都会翻倍。最开始我们是一个数一组，seg = 1，这是初始条件。然后每轮 seg 翻倍，seg = seg * 2 。这便是每轮结束时要为下一轮做的事情</p>

<p>那什么时候合并得只剩一个组——排序后的数组呢？不妨从另一个角度考虑：什么时候还得继续合并呢？当然是仍剩下多个小组的时候啦！此时每个小组长度必然小于原数组，这对应条件：<code class="highlighter-rouge">seg ≤ rightmost</code><br />
由此可以构造 for 循环：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//从左到右内循环
</span><span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">seg = seg * 2</code> 换成 <code class="highlighter-rouge">seg &lt;&lt;= 1</code> ，一方面是为了装逼，另一方面，据说可以提高计算效率</p>

<p>之前说过，外循环发生迭代，将本轮的结果用于下一轮，在合并排序的例子里，就是将 aftermerger 的结果用于下一轮。怎么用？当然是使得 本轮末的 aftermerger 成为下一轮初的 beforemerger。于是有：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">beforemerger</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">;</span>
</code></pre>
</div>

<p>鉴于合并前数组长什么样已经没用了，那不妨利用起 beforemerger 对应的空间，把它当做下一轮存放合并后数组的容器，即下一轮的 aftermerger。这样，每轮从左到右内循环之前，我们要做的是交换 beforemerger 和 aftermerger 对应的空间。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="n">temp</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">,</span> <span class="n">beforemerger</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">,</span> <span class="n">aftermerger</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="section-14">从上到下循环的代码</h3>
<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*----- 交换 beforemerger 和 aftermerger -----*/</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">,</span> <span class="n">beforemerger</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">,</span> <span class="n">aftermerger</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="cm">/*----- 从左到右内循环 -----*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
        <span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
        
        <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
 
</code></pre>
</div>

<h1 id="section-15">合并排序前后</h1>

<h2 id="section-16">准备</h2>
<p>合并排序需要的信息有原数组 array 以及原数组下标最大值 rightmost。一切开始之前，要准备好 temp、beforemerger、aftermerger 三个指针。beforemerger 自然应该是原数组 array，而第一次使用 aftermerger 时，要给它一块装得下原数组的空间。考虑到交换的部分，不妨先把原数组 array 赋给 aftermerger，而把新空间赋给 beforemerger，这样，在第一次交换后，就能达到预期的效果。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="kt">void</span> <span class="nf">mergesort</span><span class="p">(</span><span class="kt">int</span> <span class="n">rightmost</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">beforemerger</span><span class="p">,</span> <span class="o">*</span><span class="n">aftermerger</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="n">beforemerger</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rightmost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">aftermerger</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
    
    <span class="c1">// 合并排序（从上到下循环）
</span><span class="p">}</span>
</code></pre>
</div>

<h2 id="section-17">善后</h2>
<p>合并排序完了，得到的 aftermerger 就是我们要的排序后数组。合并排序过程中，我们实际上是把原数组 array 的空间和一开始申请的新空间轮流换给 beforemerger 和 aftermerger，换来换去，也不知道最终谁是谁</p>

<p>如果结束后 aftermerger 用的就是原数组 array 的空间，那就省心了，接下来释放掉 beforemerger 对应的新空间就好了。要是结束后 aftermerger 用的是新申请的那块新空间，那还要把 aftermerger 里的结果复制回原数组 array 的空间去，这种情况下原数组的空间是 beforemerger 了</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span>
<span class="c1">// 合并排序（从上到下循环）
</span><span class="k">if</span> <span class="p">(</span><span class="n">aftermerger</span> <span class="o">!=</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">free</span><span class="p">(</span><span class="n">aftermerger</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="n">free</span><span class="p">(</span><span class="n">beforemerger</span><span class="p">);</span>
</code></pre>
</div>

<h1 id="section-18">模块搭建</h1>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/*----- 准备 -----*/</span>
    <span class="c1">// 三指针声明
</span>    <span class="c1">// 初始化
</span><span class="cm">/*----- 合并排序（从上到下外循环） -----*/</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 交换 beforemerger 和 aftermerger
</span>        
	<span class="cm">/*----- 从左到右内循环 -----*/</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;)</span> <span class="p">{</span>
        <span class="cm">/*----- 小组指针初始化 -----*/</span>
	        <span class="c1">// 四个小组指针，注意end1、end2的特殊情况
</span>        <span class="cm">/*----- 核心部分 -----*/</span>
	        <span class="c1">// 交叉
</span>	        <span class="c1">// 移入
</span>    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*----- 善后 -----*/</span>
    <span class="c1">// 结果复制回 array
</span>    <span class="c1">// free
</span></code></pre>
</div>

<h1 id="section-19">合并排序的代码</h1>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// C code
</span><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span><span class="kt">void</span> <span class="nf">mergesort</span><span class="p">(</span><span class="kt">int</span> <span class="n">rightmost</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">beforemerger</span><span class="p">,</span> <span class="o">*</span><span class="n">aftermerger</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="n">beforemerger</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rightmost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">aftermerger</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">,</span> <span class="n">beforemerger</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">,</span> <span class="n">aftermerger</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;)</span> <span class="p">{</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">seg</span><span class="p">;</span>
            <span class="n">end1</span> <span class="o">=</span> <span class="p">((</span><span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">end2</span> <span class="o">=</span> <span class="p">((</span><span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span> <span class="o">&gt;</span> <span class="n">rightmost</span><span class="p">)</span> <span class="o">?</span> <span class="n">rightmost</span> <span class="o">:</span> <span class="n">end1</span> <span class="o">+</span> <span class="n">seg</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="o">?</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">beforemerger</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aftermerger</span> <span class="o">!=</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rightmost</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aftermerger</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">free</span><span class="p">(</span><span class="n">aftermerger</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">free</span><span class="p">(</span><span class="n">beforemerger</span><span class="p">);</span>
<span class="p">}</span>
 
</code></pre>
</div>

<h1 id="section-20">参考文献</h1>

<p><a href="https://zh.wikipedia.org/wiki/归并排序#C.E8.AA.9E.E8.A8.80" target="_blank">归并排序 - 维基百科，自由的百科全书</a></p>

          <a id="article-end-anchor"></a>
          <!-- comment.html starts -->
<hr class="hr-below-something">


<!-- 多说 Share start -->
<div class="ds-share"
    style=""
    data-thread-key="/2016/02/20/merge-sort"
    data-title="合并排序"
    data-url="https://matrixans.github.io/2016/02/20/merge-sort.html"
    data-images=""
    data-content="| matrix answer" >
    <div class="pseudo-ds-meta"></div>
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">Share on</a></li>
        <li><a class="ds-wechat flat" href="javascript:;" data-service="wechat">Wechat</a></li>
        <li><a class="ds-weibo flat" href="javascript:;" data-service="weibo">Weibo</a></li>
        <li> <a class="ds-twitter flat" href="javascript:;" data-service="twitter">Twitter</a> </li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
</div>
<!-- 多说 Share end-->



<ul class="pager">
    
    
    <li class="next">
        <a href="/2016/03/13/output-format-comparison-between-printf-and-stream.html" data-toggle="tooltip" data-placement="top" title="常用输出格式归纳：printf 和 stream">Next Post &rarr;</a>
    </li>
    
</ul>

<!-- 多说评论框 starts -->

<div class="ds-thread"
     data-thread-key="/2016/02/20/merge-sort"
     data-title="合并排序"
     data-url="https://matrixans.github.io/2016/02/20/merge-sort.html">
</div>

<!-- 多说评论框 ends -->

<!-- disqus 评论框 start -->

<!-- disqus 评论框 end -->


<!-- comment.html ends -->
          
      </div>
    <!-- Side Catalog Container -->

      <div class="
          col-lg-2 col-lg-offset-0
          visible-lg-block
          sidebar-container
          catalog-container">
          <div class="side-catalog">
              <h5>
                  <a class="catalog-toggle" href="#">CATALOG</a>
              </h5>
              <ul class="catalog-body"></ul>
          </div>
      </div>

      <!-- sidebar container -->
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1
                sidebar-container">
        <!-- featured-tags.html starts -->

<section>
  <hr class="hr-below-something">
  <h5>FEATURED TAGS</h5>
  <div class="tags">
    
    
    <a href="/tags.html#排序" title="排序" rel="1">排序</a>
    
    
    
    <a href="/tags.html#归纳" title="归纳" rel="1">归纳</a>
    
    
    
    <a href="/tags.html#C / C++" title="C / C++" rel="1">C / C++</a>
    
    
  </div>
</section>

<!-- featured-tags.html ends -->
        <!-- friends.html starts -->

<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
</ul>

<!-- friends.html ends -->
      </div>
    </div>
  </div>
</article>



<!-- async load function -->
<script>
  function async(u, c) {
    var d = document, t = 'script',
        o = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
  async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
    anchors.options = {
      visible: 'always',
      placement: 'right',
      icon: '#'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  })
</script>


<script src="/js/jquery.js"></script>
<!--<script src="/js/jquery.nav.js"></script>
<script src="/js/highlight.pack.js"></script>-->

<script type="text/javascript">
  async("/js/jquery.nav.js", function() {
    async("/js/highlight.pack.js", function() {
       $(document).ready(function() {
         var lanMap = {
           "language-kramdown": 'language-markdown',
           "language-trueBash": 'language-bash',
           "language-git": 'language-bash'
         };
         hljs.configure({"lineNode": true});
         $('pre code').each(function(i, e) {
          var result = this.className.match(/language-[\w]{1,}/);
          if (!result) return;
          if (lanMap[result[0]]) {
            this.classList.remove(result[0]);
            this.classList.add(lanMap[result[0]]);
          }
          hljs.highlightBlock(this);
        });
        $('div.highlighter-rouge').each(function(i, e) {
          var code = $(this).find('code');
          var result = $(this).attr('class').match(/language-[\w]{1,}/);
          if (result) code.addClass(result[0]);
          hljs.highlightBlock(code[0]);
        });
      });
      function generateCatalog (selector) {
          var P = $('div.post-container'),a,n,t,l,i,c;
          a = P.find('h1,h2,h3,h4,h5,h6');
          a.each(function () {
              n = $(this).prop('tagName').toLowerCase();
              i = "#"+$(this).prop('id');
              t = $(this).text();
              c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
              l = $('<li class="'+n+'_nav"></li>').append(c);
              $(selector).append(l);
          });
          return true;    
      }

      generateCatalog(".catalog-body");

      // toggle side catalog
      $(".catalog-toggle").click((function(e){
          e.preventDefault();
          $('.side-catalog').toggleClass("fold")
      }));

      $('.catalog-body').onePageNav({
        currentClass: "active",
        changeHash: !1,
        easing: "swing",
        filter: "",
        scrollSpeed: 700,
        scrollOffset: 100,
        scrollThreshold: 0,
        begin: null,
        end: null,
        scrollChange: null,
        endSelector: '#article-end-anchor',
        unbindSelector: null
      });
    });
    
  });
</script>


    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          <!--
          <li>
              <a href="/feed.xml">
                  <span class="fa-stack fa-lg">
                      <i class="fa fa-circle fa-stack-2x"></i>
                      <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                  </span>
              </a>
          </li>
          -->
          
        </ul>
        <p class="copyright text-muted">
          
          Copyright &copy; Mensu 2016 - 
          <br/>
          Theme edited by <a href="https://github.com/Mensu">Mensu</a> |
          <iframe frameborder="0" scrolling="0" src="https://ghbtns.com/github-btn.html?user=Mensu&repo=mensu.github.io&type=star&count=true" >
          </iframe>
          <br/>
          forked from <a href="http://huangxuan.me">Hux</a> |
          <iframe frameborder="0" scrolling="0" src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
          </iframe>
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="/js/jquery.js "></script>
<script src="/js/hux-blog.js "></script>
<script src="/js/bootstrap.js"></script>

<!-- 多说公共JS代码 starts -->

<script type="text/javascript">
var duoshuoQuery = {short_name:"mensu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    //ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.src = "/js/duoshuo-embed.js";
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>

<!-- 多说公共JS代码 ends -->

<script src="/js/mensu-blog.js"></script>

<!-- disqus 公共JS代码 starts -->

<!-- disqus 公共JS代码 ends -->

<!-- async load function -->
<script>
  function async(u, c) {
  var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
  o.src = u;
  if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
  s.parentNode.insertBefore(o, s);
  }
</script>

<!-- Highlight.js -->
<script>
  // async("/js/highlight.min.js", function(){
  //     hljs.initHighlightingOnLoad();
  // })
  // only load tagcloud.js in tag.html
  if($('#tag_cloud').length !== 0){
      async("/js/jquery.tagcloud.js",function(){
          $.fn.tagcloud.defaults = {
              //size: {start: 1, end: 1, unit: 'em'},
              color: {start: '#bbbbee', end: '#0085a1'},
          };
          $('#tag_cloud a').tagcloud();
      })
  }
</script>
<!--<link href="/css/github.min.css" rel="stylesheet">-->

<!--fastClick.js -->
<script>
    async("/js/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>
</html>
